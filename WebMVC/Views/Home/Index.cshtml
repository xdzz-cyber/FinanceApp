@using Microsoft.AspNetCore.Mvc.Localization

@{
    ViewData["Title"] = "Home Page";
    Layout = "_Layout";
}

@model CoinsVm
@inject IViewLocalizer Localizer


<div class="text-center mx-auto">
    <h1 class="display-4">@Localizer["WelcomeMessage"].Value</h1>
</div>


<div class="card-container">
    @foreach (var coin in Model.Coins)
    {
        <div class="card">
            <h3>@coin.Name</h3>
            <p>@coin.Symbol</p>
            <p id="@($"price-{coin.Name.ToLower()}")">Price: @coin.PriceUsd USD</p>
            @* <canvas id="@($"chart-{coin.Name.ToLower()}")" height="100"></canvas> *@
            <div id="@($"chart-container-{coin.Name.ToLower()}")">
                <canvas id="@($"chart-{coin.Name.ToLower()}")" height="100"></canvas>
            </div>
        </div>
    }
</div>


<div class="pagination">
    <nav>
        <ul class="pagination justify-content-center">
            @if (Model.StartPage > 1)
            {
                <li class="page-item">
                    <a class="page-link" asp-action="Index" asp-controller="Home" asp-route-page="1">First</a>
                </li>
            }

            @for (var i = Model.StartPage; i <= Model.EndPage; i++)
            {
                <li class="page-item @(i == Model.CurrentPage ? "active" : "")">
                    <a class="page-link" asp-action="Index" asp-controller="Home" asp-route-page="@i">@i</a>
                </li>
            }

            @if (Model.EndPage < Model.TotalPages)
            {
                <li class="page-item">
                    <a class="page-link" asp-action="Index" asp-controller="Home" asp-route-page="@Model.TotalPages">Last</a>
                </li>
            }
        </ul>
    </nav>
</div>

<script>
    let connection = new signalR.HubConnectionBuilder().withUrl("/coinsHub").build();
    const coins = @Html.Raw(Json.Serialize(Model.Coins.Select(c => c.Name.ToLower())));
    // Object to store latest price for each coin
        let latestPrices = coins.reduce((obj, coin) => {
            obj[coin] = null;
            return obj;
        }, {});
    
        // Object to store historical data for each coin
        let coinData = coins.reduce((obj, coin) => {
            obj[coin] = {
                prices: [], // Array to store historical prices
                maxBars: 7, // Maximum number of bars to display
            };
            return obj;
        }, {});
    
        // Chart.js configuration
        let chartOptions = {
            responsive: true,
            scales: {
                y: {
                    beginAtZero: true,
                    ticks: {
                        precision: 0,
                        stepSize: 0.1, // Increment by 1 unit
                        maxTicksLimit: 10, // Maximum number of ticks (labels) to display
                    },
                },
            },
        };
        
        let coinCharts = coins.reduce((obj, coin) => {
            let canvasId = `chart-${coin}`;
            let canvasElement = document.getElementById(canvasId);
            let ctx = canvasElement.getContext("2d");
            let chart = new Chart(ctx, {
                type: "bar",
                data: {
                    labels: [],
                    datasets: [{
                        label: coin,
                        data: [],
                        backgroundColor: "rgba(75, 192, 192, 0.5)",
                        borderColor: "rgba(75, 192, 192, 1)",
                        borderWidth: 1,
                        barThickness: 5, // Adjust the thickness of bars
                        maxBarThickness: 10, // Adjust the maximum thickness of bars
                        minBarLength: 2,
                    }],
                },
                options: chartOptions,
            });
            obj[coin] = chart;
            return obj;
        }, {});
    
    
    connection.start()
            .then(function () {
                console.log("SignalR connection established.")
            })
            .catch(function (err) {
                console.error(err.toString());
            });
        
         setInterval(function () {
                connection.invoke("UpdateCoinPrices", coins)
                    .catch(function (error) {
                        console.error("Error updating coin prices:", error);
                    });
            }, 2000); // Update every two seconds
    
        connection.on("ReceiveCoinPrices", function (prices) {
            // Update coin prices in the HTML
            const data = JSON.parse(prices).data;
            // Update coin prices in the HTML
            console.log("inside ReceiveCoinPrices", data);
            data.forEach(function (coin) {
                //const priceElement = document.getElementById("price-" + coin.name.toLowerCase());
                const chartContainer = document.getElementById("chart-container-" + coin.name.toLowerCase());
                let priceElement = document.getElementById("price-" + coin.name.toLowerCase());
                if (priceElement && chartContainer) {
                    priceElement.textContent = `Price: ${Number(coin.priceUsd).toPrecision(6)} USD`;
                }
                let coinHistory = coinData[coin.name.toLowerCase()];
                
                            // Check if the new price is different from the latest price
                            if (coin.priceUsd !== latestPrices[coin.name.toLowerCase()]) {
                                // Add the new price to the historical data
                                coinHistory.prices.push(Number(coin.priceUsd).toPrecision(6));
                
                                // Limit the historical data to the maximum number of bars
                                if (coinHistory.prices.length > coinHistory.maxBars) {
                                    coinHistory.prices.shift(); // Remove the oldest price
                                }
                
                                // Update the latest price
                                latestPrices[coin.name.toLowerCase()] = coin.priceUsd;
                
                                // Update the chart data and labels
                                let chart = coinCharts[coin.name.toLowerCase()];
                                chart.data.labels = coinHistory.prices.map((_, index) => `Price ${index + 1}`);
                                chart.data.datasets[0].data = coinHistory.prices;
                
                                // Update the chart
                                chart.update();
                            }
            });
        });
</script>